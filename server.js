// =====================================================================
// üåê CONFIGURA√á√ÉO GERAL DO SERVIDOR EXPRESS + POSTGRES + JWT + BCRYPT
// (Baseado no C√≥digo 1, expandido com as rotas do C√≥digo 2)
// =====================================================================

// 1. CARREGAR VARI√ÅVEIS DE AMBIENTE (DEVE SER O PRIMEIRO!)
require('dotenv').config();

// 2. IMPORTAR LIBS
const express = require('express');
const bodyParser = require('body-parser');
const cors = require('cors');
const morgan = require('morgan');
const bcrypt = require('bcrypt');
const jwt = require('jsonwebtoken');
const path = require('path');
const pool = require('./db'); // conex√£o com PostgreSQL

// Checa se o arquivo firebase.js existe antes de tentar importar
const adminFirebase = require.resolve('./firebase') ? require('./firebase') : null;

// 3. CONFIGURAR EXPRESS
const app = express();
const PORT = process.env.PORT || 10000; // Prefer√™ncia pela porta do C√≥digo 1

// 4. MIDDLEWARES GLOBAIS
app.use(cors({ origin: '*' }));
app.use(bodyParser.json());
app.use(morgan('combined'));

// 5. JWT Middleware (Do C√≥digo 1)
function authMiddleware(req, res, next) {
  const header = req.headers['authorization'];
  if (!header) return res.status(401).json({ success: false, message: 'Token ausente.' });

  const token = header.split(' ')[1];
  if (!token) return res.status(401).json({ success: false, message: 'Formato do Token inv√°lido.' });

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    req.user = decoded; // { id, role }
    next();
  } catch (err) {
    return res.status(403).json({ success: false, message: 'Token inv√°lido ou expirado.' });
  }
}

// 6. Middleware de Autoriza√ß√£o por Role
function roleMiddleware(requiredRole) {
  return (req, res, next) => {
    if (req.user.role !== requiredRole) {
      return res.status(403).json({ success: false, message: `Acesso negado. Requer role: ${requiredRole}` });
    }
    next();
  };
}

// =====================================================================
// üß© AUTENTICA√á√ÉO E CRIA√á√ÉO DE USU√ÅRIO (C√≥digo 1 - Priorizado por Seguran√ßa)
// =====================================================================

// üß© LOGIN (com bcrypt + JWT) - Priorizado do C√≥digo 1
app.post('/login', async (req, res) => {
  try {
    const { email, senha } = req.body;
    if (!email || !senha)
      return res.status(400).json({ success: false, message: 'Email e senha s√£o obrigat√≥rios.' });

    const result = await pool.query('SELECT * FROM users WHERE email = $1', [email]);
    const user = result.rows[0];

    if (!user) return res.status(401).json({ success: false, message: 'Credenciais inv√°lidas.' });

    // Usa Bcrypt para compara√ß√£o segura (Do C√≥digo 1)
    const isMatch = await bcrypt.compare(senha, user.password_hash);
    if (!isMatch) return res.status(401).json({ success: false, message: 'Credenciais inv√°lidas.' });

    // Gera o JWT (Do C√≥digo 1)
    const token = jwt.sign({ id: user.id, role: user.role }, process.env.JWT_SECRET, {
      expiresIn: '8h',
    });

    res.json({
      success: true,
      user: { id: user.id, name: user.name, role: user.role },
      token,
    });
  } catch (err) {
    console.error('Erro no login:', err);
    res.status(500).json({ success: false, message: 'Erro interno no login.' });
  }
});

// üßæ ROTA DE CRIA√á√ÉO DE USU√ÅRIOS (com bcrypt) - Priorizado do C√≥digo 1
// Em um cen√°rio real, esta rota tamb√©m estaria protegida por um admin, mas aqui a mantemos p√∫blica para cadastro inicial.
app.post('/users', async (req, res) => {
  try {
    const { name, email, senha, role } = req.body;
    if (!name || !email || !senha || !role)
      return res.status(400).json({ success: false, message: 'Campos obrigat√≥rios ausentes.' });

    const existing = await pool.query('SELECT id FROM users WHERE email = $1', [email]);
    if (existing.rows.length > 0)
      return res.status(400).json({ success: false, message: 'Email j√° cadastrado.' });

    const password_hash = await bcrypt.hash(senha, 10);
    await pool.query('INSERT INTO users (name, email, password_hash, role) VALUES ($1, $2, $3, $4)', [
      name,
      email,
      password_hash,
      role,
    ]);

    res.status(201).json({ success: true, message: 'Usu√°rio criado com sucesso.' });
  } catch (err) {
    console.error('Erro ao criar usu√°rio:', err);
    res.status(500).json({ success: false, message: 'Erro ao criar usu√°rio.' });
  }
});

// =====================================================================
// üë§ ROTAS DE USU√ÅRIOS (Do C√≥digo 2, Securizadas)
// =====================================================================

// 2Ô∏è‚É£ Rota: LISTAR TODOS OS USU√ÅRIOS (APENAS ADMIN)
app.get('/users', authMiddleware, roleMiddleware('admin'), async (req, res) => {
    try {
        const result = await pool.query(
            'SELECT id, name, email, role FROM users ORDER BY name ASC'
        );
        res.json({ success: true, users: result.rows });
    } catch (err) {
        console.error('Erro em GET /users:', err);
        res.status(500).json({ success: false, error: 'Erro ao listar usu√°rios.' });
    }
});

// üÜï Rota 2.1: LISTAR SOMENTE T√âCNICOS (Para Admin/Vendedor que precisa atribuir)
app.get('/technicians', authMiddleware, async (req, res) => {
    // Vendedor e Admin podem ver a lista de t√©cnicos
    if (req.user.role !== 'admin' && req.user.role !== 'seller') {
        return res.status(403).json({ success: false, message: 'Acesso negado.' });
    }

    try {
        const result = await pool.query(
            "SELECT id, name FROM users WHERE role = 'tech' ORDER BY name ASC"
        );
        res.json({ success: true, technicians: result.rows });
    } catch (err) {
        console.error('Erro em GET /technicians:', err);
        res.status(500).json({ success: false, error: 'Erro ao listar t√©cnicos.' });
    }
});

// =====================================================================
// üîé ROTAS DE CLIENTES (Do C√≥digo 2, Securizadas)
// =====================================================================

// 5Ô∏è‚É£ Rota: BUSCA DE CLIENTE (POR IDENTIFIER - CPF/CNPJ)
app.get('/clients/search', authMiddleware, async (req, res) => {
    // Apenas Admin e Vendedor podem buscar clientes
    if (req.user.role !== 'admin' && req.user.role !== 'seller') {
        return res.status(403).json({ success: false, message: 'Acesso negado.' });
    }
    
    const { identifier } = req.query;

    if (!identifier) {
        return res.status(400).json({ success: false, error: 'O identificador (CPF/CNPJ) do cliente √© obrigat√≥rio.' });
    }

    try {
        const clientResult = await pool.query(
            'SELECT id, name, address, identifier, phone_number FROM customers WHERE identifier = $1', 
            [identifier]
        );
        const client = clientResult.rows[0];

        if (!client) {
            return res.status(404).json({ success: false, error: 'Cliente n√£o encontrado.' });
        }

        res.json({
            success: true,
            id: client.id,
            name: client.name,
            address: client.address,
            phoneNumber: client.phone_number 
        });

    } catch (err) {
        console.error('Erro em GET /clients/search:', err);
        res.status(500).json({ success: false, error: 'Erro interno do servidor ao buscar cliente.', details: err.message });
    }
});


// =====================================================================
// üé´ ROTAS DE TICKETS (Do C√≥digo 2, Securizadas)
// =====================================================================

// 6Ô∏è‚É£ Rota: Vendedora cria ticket (Suporte a Cliente Novo/Existente)
app.post('/ticket', authMiddleware, async (req, res) => {
    // Apenas vendedores podem criar tickets
    if (req.user.role !== 'seller') {
        return res.status(403).json({ success: false, message: 'Apenas vendedores podem criar tickets.' });
    }

    const { title, description, priority, requestedBy, clientId, customerName, address, identifier, phoneNumber } = req.body;
    
    // O ID do solicitante deve ser o mesmo do usu√°rio logado (seguran√ßa)
    if (requestedBy != req.user.id) {
        return res.status(403).json({ success: false, message: 'Tentativa de criar ticket para outro usu√°rio.' });
    }

    // [L√≥gica de valida√ß√£o do C√≥digo 2]
    if (!title || !description || !priority || !requestedBy || !customerName) {
        return res.status(400).json({ success: false, error: 'Campos essenciais (t√≠tulo, descri√ß√£o, prioridade, solicitante, nome) s√£o obrigat√≥rios.' });
    }
    
    if (!clientId && (!address || !phoneNumber || !identifier)) {
        return res.status(400).json({ success: false, error: 'Para novo cliente, endere√ßo, telefone e CPF/CNPJ s√£o obrigat√≥rios.' });
    }
    
    if (clientId && (!address || !phoneNumber)) {
        return res.status(400).json({ success: false, error: 'O endere√ßo e o telefone do cliente s√£o obrigat√≥rios, mesmo para clientes existentes.' });
    }

    const clientDB = await pool.connect();
    let finalClientId = clientId;

    try {
        await clientDB.query('BEGIN');

        // [L√≥gica de Cliente NOVO/EXISTENTE do C√≥digo 2]
        if (!clientId) {
            const existingIdResult = await clientDB.query(
                'SELECT id FROM customers WHERE identifier = $1',
                [identifier]
            );

            if (existingIdResult.rows.length > 0) {
                await clientDB.query('ROLLBACK');
                return res.status(409).json({ success: false, error: `O identificador ${identifier} j√° est√° cadastrado em nossa base.` });
            }

            const newClientResult = await clientDB.query(
                'INSERT INTO customers (name, address, identifier, phone_number) VALUES ($1, $2, $3, $4) RETURNING id',
                [customerName, address, identifier, phoneNumber]
            );
            finalClientId = newClientResult.rows[0].id;

        } else {
            const existingClient = await clientDB.query('SELECT id FROM customers WHERE id = $1', [clientId]);
            if (existingClient.rows.length === 0) {
                await clientDB.query('ROLLBACK');
                return res.status(404).json({ success: false, error: 'Cliente existente n√£o encontrado com o ID fornecido.' });
            }

            // Atualiza o cliente existente
            await clientDB.query(
                'UPDATE customers SET name = $1, address = $2, phone_number = $3 WHERE id = $4',
                [customerName, address, phoneNumber, clientId]
            );
            finalClientId = clientId;
        }

        // Insere o novo ticket com status PENDING
        const result = await clientDB.query(
            `INSERT INTO tickets
             (title, description, priority, customer_id, customer_name, customer_address, requested_by, assigned_to, status)
             VALUES ($1, $2, $3, $4, $5, $6, $7, NULL, 'PENDING') RETURNING *`,
            [
                title,
                description,
                priority,
                finalClientId,
                customerName,
                address,
                requestedBy
            ]
        );

        await clientDB.query('COMMIT');
        res.status(201).json({ success: true, ticket: result.rows[0] });

    } catch (err) {
        await clientDB.query('ROLLBACK');
        console.error('Erro em POST /ticket (Transa√ß√£o):', err);
        if (err.code === '23505') { 
            return res.status(409).json({ success: false, error: `O identificador (CPF/CNPJ) j√° est√° cadastrado em nossa base.` });
        }
        res.status(500).json({ success: false, error: 'Erro interno do servidor ao criar ticket. Tente novamente.', details: err.message });
    } finally {
        clientDB.release();
    }
});


// 3Ô∏è‚É£ Rota: LISTAR TODOS OS TICKETS (APENAS ADMIN)
app.get('/tickets', authMiddleware, roleMiddleware('admin'), async (req, res) => {
    // Esta rota usa a implementa√ß√£o de jun√ß√£o do C√≥digo 2 (traz assigned_to_name)
    try {
        const result = await pool.query(
            `SELECT
                t.*,
                u.name AS assigned_to_name
             FROM tickets t
             LEFT JOIN users u ON t.assigned_to = u.id
             ORDER BY t.created_at DESC`
        );
        res.json({ success: true, tickets: result.rows });
    } catch (err) {
        console.error('Erro em GET /tickets:', err);
        res.status(500).json({ success: false, error: 'Erro ao listar todos os tickets.' });
    }
});

// üÜï Rota 3.1: LISTAR TICKETS POR SOLICITANTE (VENDEDOR)
app.get('/tickets/requested/:requested_by_id', authMiddleware, async (req, res) => {
    const requestedById = req.params.requested_by_id;

    // Acesso seguro: O vendedor s√≥ pode ver os tickets que ele mesmo solicitou
    if (req.user.role !== 'admin' && req.user.id != requestedById) {
        return res.status(403).json({ success: false, message: 'Acesso negado. Voc√™ s√≥ pode ver seus pr√≥prios tickets.' });
    }

    try {
        const result = await pool.query(
            `SELECT
                t.*,
                u.name AS assigned_to_name
             FROM tickets t
             LEFT JOIN users u ON t.assigned_to = u.id
             WHERE t.requested_by = $1
             ORDER BY t.created_at DESC`,
            [requestedById]
        );
        res.json({ success: true, tickets: result.rows });
    } catch (err) {
        console.error('Erro em GET /tickets/requested/:requested_by_id:', err);
        res.status(500).json({ success: false, error: 'Erro ao listar tickets solicitados.' });
    }
});

// 9Ô∏è‚É£ Rota: T√©cnico lista tickets aprovados (Somente status = 'APPROVED' e 'IN_PROGRESS')
app.get('/tickets/assigned/:tech_id', authMiddleware, async (req, res) => {
    const techIdParam = req.params.tech_id;
    
    // Acesso seguro: O t√©cnico s√≥ pode ver os tickets atribu√≠dos a ele mesmo
    if (req.user.role !== 'admin' && req.user.id != techIdParam) {
        return res.status(403).json({ success: false, message: 'Acesso negado. Voc√™ s√≥ pode ver tickets atribu√≠dos a voc√™.' });
    }

    const techId = parseInt(techIdParam, 10);
    
    if (isNaN(techId)) {
        return res.status(400).json({ success: false, error: 'O ID do t√©cnico fornecido n√£o √© um n√∫mero v√°lido.' });
    }

    try {
        const result = await pool.query(
            `SELECT
                t.*,
                u.name AS approved_by_admin_name
             FROM tickets t
             LEFT JOIN users u ON t.approved_by = u.id
             WHERE t.status IN ('APPROVED', 'IN_PROGRESS') AND t.assigned_to = $1
             ORDER BY t.created_at DESC`,
            [techId]
        );
        res.json({ success: true, tickets: result.rows });
    } catch (err) {
        console.error('Erro em GET /tickets/assigned/:tech_id:', err);
        res.status(500).json({ success: false, error: 'Erro ao listar tickets' });
    }
});

// 7Ô∏è‚É£ Rota: Administrativo aprova ticket + Atribui√ß√£o de T√©cnico + Notifica√ß√£o FCM
app.put('/tickets/:id/approve', authMiddleware, roleMiddleware('admin'), async (req, res) => {
    const ticketId = req.params.id;
    const { assigned_to } = req.body;
    // O admin_id √© pego diretamente do token seguro
    const admin_id = req.user.id; 

    const client = await pool.connect();

    try {
        await client.query('BEGIN');
        
        if (!assigned_to) {
            await client.query('ROLLBACK');
            return res.status(400).json({ success: false, error: 'O ID do t√©cnico para atribui√ß√£o √© obrigat√≥rio para aprovar o ticket.' });
        }

        // Checagem se o assigned_to √© um t√©cnico
        const techResCheck = await client.query(
            'SELECT id FROM users WHERE id = $1 AND role = \'tech\'',
            [assigned_to]
        );
        if (techResCheck.rows.length === 0) {
            await client.query('ROLLBACK');
            return res.status(404).json({
                success: false,
                error: `T√©cnico com ID ${assigned_to} n√£o encontrado ou n√£o tem o cargo 'tech'.`,
            });
        }

        // Atualiza o ticket: define status como 'APPROVED' e atribui o t√©cnico
        const update = await client.query(
            `UPDATE tickets
             SET status = 'APPROVED', approved_by = $1, approved_at = now(), assigned_to = $2
             WHERE id = $3 RETURNING *`,
            [admin_id, assigned_to, ticketId]
        );

        const ticket = update.rows[0];

        if (!ticket) {
            await client.query('ROLLBACK');
            return res.status(404).json({ success: false, error: 'Ticket n√£o encontrado.' });
        }

        // [L√≥gica de Notifica√ß√£o FCM do C√≥digo 2 - Mantida]
        let notification_sent = false;
        // ... (resto da l√≥gica de notifica√ß√£o FCM do C√≥digo 2) ...

        await client.query('COMMIT');
        res.json({ success: true, ticket, notification_sent });

    } catch (err) {
        await client.query('ROLLBACK');
        console.error('Erro cr√≠tico em PUT /tickets/:id/approve (Transa√ß√£o):', err);
        res.status(500).json({ success: false, error: 'Erro ao aprovar ticket e enviar notifica√ß√£o', details: err.message });
    } finally {
        client.release();
    }
});

// üÜï Rota 8Ô∏è‚É£: Administrativo REJEITA/REPROVA ticket
app.put('/tickets/:id/reject', authMiddleware, roleMiddleware('admin'), async (req, res) => {
    const ticketId = req.params.id;
    // O admin_id √© pego diretamente do token seguro
    const admin_id = req.user.id; 

    try {
        const result = await pool.query(
            `UPDATE tickets
             SET status = 'REJECTED', approved_by = $1, approved_at = now(), assigned_to = NULL
             WHERE id = $2 RETURNING *`,
            [admin_id, ticketId]
        );

        const ticket = result.rows[0];

        if (!ticket) {
            return res.status(404).json({ success: false, error: 'Ticket n√£o encontrado para ser reprovado.' });
        }

        res.status(200).json({
            success: true,
            message: `Ticket ID ${ticketId} foi reprovado com sucesso e seu status foi atualizado para REJECTED.`,
            ticket: ticket
        });

    } catch (err) {
        console.error('Erro em PUT /tickets/:id/reject:', err);
        res.status(500).json({ success: false, error: 'Erro ao reprovar ticket.', details: err.message });
    }
});


// üÜï Rota 10: ATUALIZA√á√ÉO DO STATUS DO TICKET (USADO PELO T√âCNICO)
app.put('/tickets/:id/status', authMiddleware, async (req, res) => {
    const ticketIdParam = req.params.id;
    const { new_status } = req.body;

    // O user_id √© pego diretamente do token seguro
    const user_id = req.user.id;

    // 1. Valida√ß√£o do C√≥digo 2
    if (!new_status) {
        return res.status(400).json({ success: false, error: 'O campo new_status √© obrigat√≥rio.' });
    }
    
    const ticketId = parseInt(ticketIdParam, 10);
    const userId = parseInt(user_id, 10); 

    if (isNaN(ticketId) || isNaN(userId)) {
        return res.status(400).json({ success: false, error: 'O ID do ticket ou do usu√°rio n√£o √© um n√∫mero v√°lido.' });
    }
    
    const validStatus = ['IN_PROGRESS', 'COMPLETED'];
    if (!validStatus.includes(new_status)) {
        return res.status(400).json({ success: false, error: `O status fornecido "${new_status}" √© inv√°lido. Status permitidos: ${validStatus.join(', ')}.` });
    }
    
    // 2. Checagem de Autoriza√ß√£o do T√©cnico
    if (req.user.role !== 'tech') {
        return res.status(403).json({ success: false, message: 'Apenas t√©cnicos podem atualizar o status do ticket.' });
    }

    try {
        // 3. Busca e Checagem (garante que s√≥ pode atualizar se estiver atribu√≠do a ele)
        const checkResult = await pool.query(
            `SELECT 
                t.title, 
                t.requested_by AS seller_id, 
                t.status,
                tech.name AS tech_name
             FROM tickets t
             JOIN users tech ON tech.id = t.assigned_to
             WHERE t.id = $1 AND t.assigned_to = $2 AND tech.role = 'tech'`,
            [ticketId, userId]
        );

        if (checkResult.rows.length === 0) {
            return res.status(403).json({ success: false, error: 'Ticket n√£o encontrado ou n√£o est√° atribu√≠do a voc√™.' });
        }
        
        const { title: ticketTitle, seller_id: sellerId, tech_name: techName } = checkResult.rows[0];

        // 4. Atualiza o status
        const result = await pool.query(
            `UPDATE tickets
             SET status = $1, 
                 last_updated_by = $3, 
                 updated_at = now(),
                 completed_at = CASE WHEN $1 = 'COMPLETED' THEN now() ELSE completed_at END
             WHERE id = $2 RETURNING *`,
            [new_status, ticketId, userId]
        );

        const ticket = result.rows[0];

        // 5. [L√≥gica de Notifica√ß√£o FCM do C√≥digo 2 - Mantida]
        // ... (resto da l√≥gica de notifica√ß√£o FCM do C√≥digo 2) ...
        console.log(`Notifica√ß√£o FCM (simulada) para Admin/Vendedor sobre status ${new_status}.`);


        // 6. Retorno de sucesso
        res.status(200).json({
            success: true,
            message: `Status do Ticket ID ${ticketId} atualizado para ${new_status} por ${techName}.`,
            ticket: ticket
        });

    } catch (err) {
        console.error('Erro em PUT /tickets/:id/status:', err);
        res.status(500).json({ success: false, error: 'Erro ao atualizar status do ticket.', details: err.message });
    }
});


// =====================================================================
// üöÄ ROTA TESTE P√öBLICA (Do C√≥digo 1 - Health Check)
// =====================================================================
app.get('/', (req, res) => {
  res.json({
    success: true,
    message: 'API TrackerCars - Online üöó',
    version: '2.0-secure',
  });
});

// =====================================================================
// üß± CRIA√á√ÉO DE √çNDICES AUTOM√ÅTICA (executa uma vez no start) - Do C√≥digo 1
// =====================================================================
(async () => {
  try {
    // Adicionamos √≠ndices para as colunas mais usadas em WHERE/JOIN
    await pool.query(`CREATE INDEX IF NOT EXISTS idx_users_email ON users(email);`);
    await pool.query(`CREATE INDEX IF NOT EXISTS idx_tickets_assigned_to ON tickets(assigned_to);`);
    await pool.query(`CREATE INDEX IF NOT EXISTS idx_tickets_requested_by ON tickets(requested_by);`);
    await pool.query(`CREATE INDEX IF NOT EXISTS idx_customers_identifier ON customers(identifier);`);
    console.log('üîç √çndices do banco verificados/criados.');
  } catch (err) {
    console.error('Erro ao criar √≠ndices:', err);
  }
})();


// =====================================================================
// ‚öôÔ∏è TRATAMENTO DE ERROS GLOBAIS (Do C√≥digo 1/2)
// =====================================================================

// üö® TRATAMENTO DE ROTA N√ÉO ENCONTRADA (404) - DEVE SER O PEN√öLTIMO
app.use((req, res) => {
  res.status(404).json({ success: false, message: 'Rota n√£o encontrada.', path: req.originalUrl });
});

// üö® MIDDLEWARE DE TRATAMENTO DE ERRO CENTRALIZADO (500) - DEVE SER O √öLTIMO
app.use((err, req, res, next) => {
  console.error('Erro interno:', err.stack);
  const statusCode = err.statusCode || 500;
  res.status(statusCode).json({ 
    success: false, 
    message: 'Erro interno no servidor.',
    details: err.message,
    path: req.originalUrl
  });
});

// =====================================================================
// üß© INICIAR SERVIDOR
// =====================================================================
app.listen(PORT, () => {
  console.log(`‚úÖ Servidor rodando na porta ${PORT}`);
  const baseUrl = process.env.RENDER_EXTERNAL_URL || `http://localhost:${PORT}`;
  console.log(`Base URL: ${baseUrl}`);
});